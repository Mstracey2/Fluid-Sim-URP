#pragma kernel Integrate
#pragma kernel ApplyComputeForces

struct Particle {
	float pressure;
	float density;
	float3 currentForce;
	float3 velocity;
	float3 position;
};

RWStructuredBuffer<Particle> _particles;
float gravity;
float particleMass;
float viscosity;
float gasConstant;
float restDensity;
float boundDamping;
float radius;
//float radius2;
//float radius3;
//float radius4;
//float radius5;
float pi;
int particleLength;
float timestep;
float3 boxSize;

[numthreads(100,1,1)]
void Integrate(uint3 id: SV_DISPATCHTHREADID) 
{
	float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce / particleMass) * timestep);
	_particles[id.x].position += vel * timestep;

		float3 topRight = boxSize / 2;
		float3 bottomLeft = -boxSize / 2;

		if (_particles[id.x].position.x - radius < bottomLeft.x) {
			vel.x *= boundDamping;
			_particles[id.x].position.x = bottomLeft.x + radius;
		}
		if (_particles[id.x].position.y - radius < bottomLeft.y) {
			vel.y *= boundDamping;
			_particles[id.x].position.y = bottomLeft.y + radius;
		}
		if (_particles[id.x].position.z - radius < bottomLeft.z) {
			vel.z *= boundDamping;
			_particles[id.x].position.z = bottomLeft.z + radius;
		}
		if (_particles[id.x].position.x + radius > topRight.x) {
			vel.x *= boundDamping;
			_particles[id.x].position.x = topRight.x - radius;
		}
		if (_particles[id.x].position.y + radius > topRight.y) {
			vel.y *= boundDamping;
			_particles[id.x].position.y = topRight.y - radius;
		}
		if (_particles[id.x].position.z + radius > topRight.z) {
			vel.z *= boundDamping;
			_particles[id.x].position.z = topRight.z - radius;
		}

		_particles[id.x].velocity = vel;
}

//float StdKernel(float distanceSquared)
//{
//	float x = 1.0f - distanceSquared / radius2;
//	return 315.f / (64.f * pi * radius3) * x * x * x;
	
//}

float SmoothingKernal(float distance)
{
    float volume = pi * pow(radius, 8) / 4;
	//currently a spiked gradient, to smooth the gradient: distance * distance 
    float value = max(0, radius * radius - distance);
    return value * value * value/ volume;
}

//[numthreads(100, 1, 1)]
//void CalculateDensity(uint id: SV_DispatchThreadID)
//{
//    float3 particlePos = _particles[id.x].position;
//    float dens = 0;
//    for (int i = 0; i < particleLength; i++)
//    {
//        float particleDiff = (particlePos - _particles[i].position);
//        float gradientInfl = SmoothingKernal(particleDiff);
//        dens += gradientInfl * particleMass;

//    }
//    _particles[id.x].density = dens;
	
//}

//[numthreads(100, 1, 1)]
//void CalculatePressureProperty(uint id : SV_DispatchThreadID)
//{
//    float3 particlePos = _particles[id.x].position;
//    float pressureProp = 0;
//    for (int i = 0; i < particleLength; i++)
//    {
//        float particleDiff = (particlePos - _particles[i].position);
//        float gradientInfl = SmoothingKernal(particleDiff);
//        pressureProp += gradientInfl * particleMass;

//    }
//    _particles[id.x].density = dens;
	
//}

[numthreads(100, 1, 1)]
void ApplyComputeForces(uint3 id : SV_DISPATCHTHREADID)
{
    _particles[id.x].currentForce = float3(0, gravity * particleMass, 0);

}
