
#pragma kernel Integrate
#pragma kernel ApplyComputeForces
#pragma kernel CalculateDensity
#pragma kernel CalculatePressure

struct Particle {
	float pressure;
	float density;
	float3 currentForce;
	float3 velocity;
	float3 position;
};

RWStructuredBuffer<Particle> _particles;
float gravity;
float particleMass;
float boundDamping;
float radius;
float pi;
int particleLength;
float timestep;
float3 boxSize;
float densityTarget;
float pressureForce;


[numthreads(100,1,1)]
void Integrate(uint3 id: SV_DISPATCHTHREADID) 
{
	float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce / particleMass) * timestep);
	_particles[id.x].position += vel * timestep;

		float3 topRight = boxSize / 2;
		float3 bottomLeft = -boxSize / 2;

		if (_particles[id.x].position.x - radius < bottomLeft.x) {
			vel.x *= boundDamping;
			_particles[id.x].position.x = bottomLeft.x + radius;
		}
		if (_particles[id.x].position.y - radius < bottomLeft.y) {
			vel.y *= boundDamping;
			_particles[id.x].position.y = bottomLeft.y + radius;
		}
		if (_particles[id.x].position.z - radius < bottomLeft.z) {
			vel.z *= boundDamping;
			_particles[id.x].position.z = bottomLeft.z + radius;
		}
		if (_particles[id.x].position.x + radius > topRight.x) {
			vel.x *= boundDamping;
			_particles[id.x].position.x = topRight.x - radius;
		}
		if (_particles[id.x].position.y + radius > topRight.y) {
			vel.y *= boundDamping;
			_particles[id.x].position.y = topRight.y - radius;
		}
		if (_particles[id.x].position.z + radius > topRight.z) {
			vel.z *= boundDamping;
			_particles[id.x].position.z = topRight.z - radius;
		}

		_particles[id.x].velocity = vel;
}


float SmoothingKernal(float distance)
{
    float volume = pi * pow(radius, 8) / 4;
	//currently a spiked gradient, to smooth the gradient: distance * distance 
    float value = max(0, radius * radius - distance);
    return value * value * value/ volume;
}

// calculates how much pressure is required in order for the particle to reach its target density.
float GetPressureFromDensity(float density)
{
    return (density - densityTarget) * pressureForce;
}

// Calculates the density of the particle, does so by getting the distance between particles, and the density is affected via the mass and gradient influence.
[numthreads(100, 1, 1)]
void CalculateDensity(uint id : SV_DispatchThreadID)
{
    float3 particlePos = _particles[id.x].position;
    float dens = 0;
    for (int i = 0; i < particleLength; i++)
    {
        float particleDiff = (particlePos - _particles[i].position);
        float gradientInfl = SmoothingKernal(particleDiff);
        dens += gradientInfl * particleMass;

    }
    _particles[id.x].density = dens;
	
}

// calculates particle pressure, REQUIRES THE CALCULATION OF DENSITY TO KNOW HOW MUCH PRESSURE THE PARTICLE IS UNDER
[numthreads(100, 1, 1)]
void CalculatePressure(uint id : SV_DispatchThreadID)
{
    float3 particlePos = _particles[id.x].position;
    float density = _particles[id.x].density;
    float pressure = GetPressureFromDensity(density);
    for (int i = 0; i < particleLength; i++)
    {
        float particleDiff = (particlePos - _particles[i].position);
        float gradientInfl = SmoothingKernal(particleDiff);
        pressureForce += pressure * gradientInfl * particleMass / density;
    }
}

// applies the calculated forces to the particle
[numthreads(100, 1, 1)]
void ApplyComputeForces(uint3 id : SV_DISPATCHTHREADID)
{
    _particles[id.x].currentForce = float3(0, gravity * particleMass, 0) - pressureForce;
}


