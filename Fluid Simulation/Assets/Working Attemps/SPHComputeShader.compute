#pragma kernel CalculateExternalForces
#pragma kernel CalculateDensity
#pragma kernel CalculatePressure
#pragma kernel CalculateViscosity
#pragma kernel ApplyForces
#pragma kernel GetSpacialHash
#pragma kernel DetectBounds

#include "./SpatialHashing.hlsl"

struct Particle {
	float3 pressure;
	float2 density;
    float3 external;
	float3 velocity;
	float3 position;
    float3 positionPrediction;
    uint3 hashData;
};

RWStructuredBuffer<Particle> _particles;
RWStructuredBuffer<uint3> hashData;
RWStructuredBuffer<uint> hashOffsetData;

float gravity;
float particleMass;
float boundDamping;
float radius;
float pi;
int particleLength;
float timestep;
float3 boxSize;
float3 boxCentre;
float densityTarget;
float pressureMulti;
float nearPressureMulti;
float viscosityMulti;
float predictionIteration;
float4x4 worldMatrix;
float4x4 localMatrix;
float3 mousePos;
float mouseRadius;
float pushPullForce;
bool pull;
bool push;
int gradientChoice;
float densityMod;

static const int xThreads = 100;

[numthreads(xThreads, 1, 1)]

void CalculateExternalForces(uint3 id : SV_DISPATCHTHREADID)
{
    float3 particleOffset = (_particles[id.x].positionPrediction - mousePos);
    float partDis = dot(particleOffset, particleOffset);
    float dist = sqrt(partDis);
    float3 dir = dist > 0 ? particleOffset / dist : float3(0, 1, 0);
    if (dist < mouseRadius)
    {
        if (pull)
        {
            _particles[id.x].velocity -= dir * pushPullForce;
        }
        if (push)
        {
            _particles[id.x].velocity += dir * pushPullForce;
        }
    }
    _particles[id.x].positionPrediction = _particles[id.x].position + _particles[id.x].velocity * 1 / predictionIteration;
    
}

[numthreads(xThreads, 1, 1)]
void GetSpacialHash(uint3 id : SV_DISPATCHTHREADID)
{
    if (id.x >= particleLength)return;

    uint index = id.x;
    hashOffsetData[index] = particleLength;
    int3 convertedCellSpace = intCoord(_particles[index].positionPrediction, radius);
    uint hash = Hash(convertedCellSpace);
    uint Key = HashKey(hash, particleLength);
    //_particles[index].hashData = uint3(index,hash,Key);
    hashData[index] =  uint3(index, hash, Key);;

}

[numthreads(xThreads, 1, 1)]
void DetectBounds(uint3 id : SV_DISPATCHTHREADID)
{
    if (id.x >= particleLength) return;
    
    // Transform position/velocity to the local space
    float3 posLocal = mul(localMatrix, float4(_particles[id.x].position, 1)).xyz;
    float3 velocityLocal = mul(localMatrix, float4(_particles[id.x].velocity, 0)).xyz;
    
    //get the distance of boxes axises
    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);
    
    // Resolve collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * boundDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * boundDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * boundDamping;
    }
    
    
    _particles[id.x].position = mul(worldMatrix, float4(posLocal, 1)).xyz;
    _particles[id.x].velocity = mul(worldMatrix, float4(velocityLocal, 0)).xyz;
    
    
}

//This Kernal type is used for the calculation of density. Theoretically, the peak is a spiked top with a harsh decline
float DensityKernal_SpikedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 15 / (2 * pi * pow(radius, 5));
        float vel = radius - dist;
        return vel * vel * scale;
    }
    return 0;
}

float NearDensityKernal_GreaterSpikedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 15 / (pi * pow(radius, 6));
        float vel = radius - dist;
        return vel * vel * vel * scale;
    }
    return 0;
}

/*
    This gradient type is used for the calculation of pressure. It has the same gradient pattern as the density, but we use this instead.
    The reasoning to why this Kernal makes the sim work and the regular density kernal doesn't, for this case, the distance between the particle reduces the value of the gradient of the kernel becomes zero making the pressure force zero.
    To avoid this, we use a modified kernal (a SPH Approximation) which in turn, gives us a modified pressure that is proportional to the density deviation. More can be found here: https://www.diva-portal.org/smash/get/diva2:573583/FULLTEXT01.pdf
*/
float DerivativeDensityKernal_DerivativeSpikedGradient(float dist)
{
    if (dist <= radius)
    {
        float scale = 15 / (pow(radius, 5) * pi);
        float vel = radius - dist;
        return vel * scale;
    }
    return 0;
}

float NearDerivativeDensityKernel_GreaterDerivativeSpikedGradient(float dist)
{
    if (dist <= radius)
    {
        float scale = 45 / (pow(radius, 6) * pi);
        float vel = radius - dist;
        return vel * vel * scale;
    }
    return 0;
}

// similar to the density kernal but we square the values more to recieve a more smoothed and rounded peak on the gradient
float ViscosityKernal_RoundedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 315 / (64 * pi * pow(abs(radius), 9));
        float vel = radius * radius - dist * dist;
        return vel * vel * vel * scale;
    }
    return 0;
}

// calculates how much pressure is required in order for the particle to reach its target density.
float GetPressureFromDensity(float density)
{
    return (density - densityTarget) * pressureMulti;
}

float NearPressureFromDensity(float nearDensity)
{
    return nearDensity * nearPressureMulti;
}

/*
    According to newtons third law:
    for every action (force) in nature there is an equal and opposite reaction.
    To do this, we must calculate a shared equal pressure by getting the mean avarage of both pressures.
*/
float GetSharedPressure(float denA, float denB)
{
    float pressure1 = GetPressureFromDensity(denA);
    float pressure2 = GetPressureFromDensity(denB);
    return (pressure1, pressure2) / 2;
}

float GetNearSharedPressure(float denA, float denB)
{
    float pressure1 = NearPressureFromDensity(denA);
    float pressure2 = NearPressureFromDensity(denB);
    return (pressure1, pressure2) / 2;
}

float2 DistanceIn3DSpace(float3 particlePos, float3 neighborPos)
{
    float3 particleDiff = (neighborPos - particlePos);
    float particleOffset = dot(particleDiff, particleDiff);
    return (particleOffset, sqrt(particleOffset));
}

// Calculates the density of the particle, does so by getting the distance between particles, and the density is affected via the mass and gradient influence.
[numthreads(xThreads, 1, 1)]
void CalculateDensity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    float dens = 0;
    float nearDens = 0;
    float radiusSqr = radius * radius;
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    
    
    for (int i = 0; i < 27; i++)
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);
        uint key = HashKey(neighborCellHash, particleLength);
        uint currentOffsetKey = hashOffsetData[key];
        while (currentOffsetKey < particleLength)
        {
            uint3 offsetCellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            if (offsetCellData[2] != key)
            {
                break;
            }
            if (offsetCellData[1] != neighborCellHash)
            {
                continue;
            }
            
            
            uint neighbor = offsetCellData[0];
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);
        
            //if (neighbor == id.x)
            //{
            //    continue;
            //}
            
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            float gradientInfl = DensityKernal_SpikedGradient(dist[1]);
            dens = gradientInfl * particleMass;
            gradientInfl = NearDensityKernal_GreaterSpikedGradient(dist[1]);
            nearDens = gradientInfl * particleMass;
        }
    }
    _particles[id.x].density = float2(dens, nearDens);
	
}

// calculates particle pressure, REQUIRES THE CALCULATION OF DENSITY TO KNOW HOW MUCH PRESSURE THE PARTICLE IS UNDER
[numthreads(xThreads, 1, 1)]
void CalculatePressure(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    float3 pressureForce = 0;
    float radiusSqr = radius * radius;
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    _particles[id.x].hashData = uint3(0, 0, 0);
    for (int i = 0; i < 27; i++)
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);
        uint key = HashKey(neighborCellHash, particleLength);
        uint currentOffsetKey = hashOffsetData[key];
        
        
        while (currentOffsetKey < particleLength)
        {
            uint3 offsetCellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            if (offsetCellData[2] != key)
            {
                break;
            }
            if (offsetCellData[1] != neighborCellHash)
            {
                continue;
            }
            
            
            uint neighbor = offsetCellData[0];
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);
         
            
            if (neighbor == id.x)
            {
                continue;
            }
            
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            _particles[id.x].hashData += uint3(1,1,1);
            float3 dir = dist[1] > 0 ? (_particles[neighbor].positionPrediction - particlePos) / dist[1] : float3(0, 1, 0);
            float gradientInfl = DerivativeDensityKernal_DerivativeSpikedGradient(dist[1]);
            pressureForce += dir * gradientInfl * GetSharedPressure(_particles[id.x].density[0], _particles[neighbor].density[0]) / _particles[neighbor].density[0];
            gradientInfl = NearDerivativeDensityKernel_GreaterDerivativeSpikedGradient(dist[1]);
            pressureForce += dir * gradientInfl * GetNearSharedPressure(_particles[id.x].density[1], _particles[neighbor].density[1]) / _particles[neighbor].density[1];
        }
    }
    
    float3 acceleration = pressureForce / _particles[id.x].density[0];
    _particles[id.x].pressure = acceleration * timestep;

}


[numthreads(xThreads, 1, 1)]
void CalculateViscosity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    
    float3 viscosityForce = 0;
    float3 particlePos = _particles[id.x].positionPrediction;
    float3 currentVel = _particles[id.x].velocity;
    float radiusSqr = radius * radius;
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    
    for (int i = 0; i < 27; i++)
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);
        uint key = HashKey(neighborCellHash, particleLength);
        uint currentOffsetKey = hashOffsetData[key];
        
        while (currentOffsetKey < particleLength)
        {
            uint3 offsetCellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            if (offsetCellData[2] != key)
            {
                break;
            }
            if (offsetCellData[1] != neighborCellHash)
            {
                continue;
            }
            
            uint neighbor = offsetCellData[0];
            
            if (neighbor == id.x)
            {
                continue;
            }
            
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);
            
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            
            float gradientInfl = ViscosityKernal_RoundedGradient(dist[1]);
            viscosityForce += (_particles[neighbor].velocity - currentVel) * gradientInfl;
        }
    }
    _particles[id.x].velocity += (viscosityForce * viscosityMulti) * timestep;

}

[numthreads(xThreads, 1, 1)]
void ApplyForces(uint id : SV_DispatchThreadID)
{
    _particles[id.x].external = float3(0, gravity / particleMass, 0) * timestep;
    
    _particles[id.x].velocity += _particles[id.x].external;
    
    _particles[id.x].velocity += _particles[id.x].pressure;

    _particles[id.x].position += (_particles[id.x].velocity) * timestep;
     
}

