
#pragma kernel Integrate
#pragma kernel CalculateDensity
#pragma kernel CalculatePressure
#pragma kernel CalculateViscosity
#pragma kernel ApplyForces

struct Particle {
	float3 pressure;
	float2 density;
    float3 external;
	float3 velocity;
	float3 position;
    float3 positionPrediction;
};

RWStructuredBuffer<Particle> _particles;
float gravity;
float particleMass;
float boundDamping;
float radius;
float pi;
int particleLength;
float timestep;
float3 boxSize;
float3 boxCentre;
float densityTarget;
float pressureMulti;
float nearPressureMulti;
float viscosityMulti;
float disNum;
float4x4 worldMatrix;
float4x4 localMatrix;


[numthreads(100, 1, 1)]
void Integrate(uint3 id : SV_DISPATCHTHREADID)
{
    if (id.x >= particleLength) return;
    
    // Transform position/velocity to the local space
    float3 posLocal = mul(localMatrix, float4(_particles[id.x].position, 1)).xyz;
    float3 velocityLocal = mul(localMatrix, float4(_particles[id.x].velocity, 0)).xyz;
    
    //get the distance of boxes axises
    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);
    
    // Resolve collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * boundDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * boundDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * boundDamping;
    }
    
    
    _particles[id.x].position = mul(worldMatrix, float4(posLocal, 1)).xyz;
    _particles[id.x].velocity = mul(worldMatrix, float4(velocityLocal, 0)).xyz;
    
    //_particles[id.x].velocity = vel;
    _particles[id.x].positionPrediction = _particles[id.x].position + _particles[id.x].velocity * 1 / disNum;
}

//This Kernal type is used for the calculation of density. Theoretically, the peak is a spiked top with a harsh decline
float DensityKernal_SpikedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 15 / (2 * pi * pow(radius, 5));
        float vel = radius - dist;
        return vel * vel * scale;
    }
    return 0;
}

float NearDensityKernal_GreaterSpikedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 15 / (pi * pow(radius, 6));
        float vel = radius - dist;
        return vel * vel * vel * scale;
    }
    return 0;
}

/*
    This gradient type is used for the calculation of pressure. It has the same gradient pattern as the density, but we use this instead.
    The reasoning to why this Kernal makes the sim work and the regular density kernal doesn't, for this case, the distance between the particle reduces the value of the gradient of the kernel becomes zero making the pressure force zero.
    To avoid this, we use a modified kernal (a SPH Approximation) which in turn, gives us a modified pressure that is proportional to the density deviation. More can be found here: https://www.diva-portal.org/smash/get/diva2:573583/FULLTEXT01.pdf
*/
float DerivativeDensityKernal_DerivativeSpikedGradient(float dist)
{
    if (dist <= radius)
    {
        float scale = 15 / (pow(radius, 5) * pi);
        float vel = radius - dist;
        return vel * scale;
    }
    return 0;
}

float NearDerivativeDensityKernel_GreaterDerivativeSpikedGradient(float dist)
{
    if (dist <= radius)
    {
        float scale = 45 / (pow(radius, 6) * pi);
        float vel = radius - dist;
        return vel * vel * scale;
    }
    return 0;
}

// similar to the density kernal but we square the values more to recieve a more smoothed and rounded peak on the gradient
float ViscosityKernal_RoundedGradient(float dist)
{
    if (dist < radius)
    {
        float scale = 315 / (64 * pi * pow(abs(radius), 9));
        float vel = radius * radius - dist * dist;
        return vel * vel * vel * scale;
    }
    return 0;
}

// calculates how much pressure is required in order for the particle to reach its target density.
float GetPressureFromDensity(float density)
{
    return (density - densityTarget) * pressureMulti;
}

float NearPressureFromDensity(float nearDensity)
{
    return nearDensity * nearPressureMulti;
}

/*
    According to newtons third law:
    for every action (force) in nature there is an equal and opposite reaction.
    To do this, we must calculate a shared equal pressure by getting the mean avarage of both pressures.
*/
float GetSharedPressure(float denA, float denB)
{
    float pressure1 = GetPressureFromDensity(denA);
    float pressure2 = GetPressureFromDensity(denB);
    return (pressure1, pressure2) / 2;
}

float GetNearSharedPressure(float denA, float denB)
{
    float pressure1 = NearPressureFromDensity(denA);
    float pressure2 = NearPressureFromDensity(denB);
    return (pressure1, pressure2) / 2;
}

// Calculates the density of the particle, does so by getting the distance between particles, and the density is affected via the mass and gradient influence.
[numthreads(100, 1, 1)]
void CalculateDensity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    float dens = 0;
    float nearDens = 0;
    for (int i = 0; i < particleLength; i++)
    {
        if (id.x != i) continue;
        float3 particleDiff = (particlePos - _particles[i].positionPrediction);
        float particleOffset = dot(particleDiff, particleDiff);
        float dist = sqrt(particleOffset);
        float gradientInfl = DensityKernal_SpikedGradient(dist);
        dens += gradientInfl * particleMass;
        gradientInfl = NearDensityKernal_GreaterSpikedGradient(dist);
        nearDens += gradientInfl * particleMass;

    }
    _particles[id.x].density = float2(dens,nearDens);
	
}

// calculates particle pressure, REQUIRES THE CALCULATION OF DENSITY TO KNOW HOW MUCH PRESSURE THE PARTICLE IS UNDER
[numthreads(100, 1, 1)]
void CalculatePressure(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    float density = _particles[id.x].density;
    float3 pressureForce = 0;
    for (int i = 0; i < particleLength; i++)
    {
        if (id.x == i) continue;
        float3 particleOffset = (_particles[i].positionPrediction - particlePos);
        float partDis = dot(particleOffset, particleOffset);
        float dist = sqrt(partDis);
        
        float gradientInfl = DerivativeDensityKernal_DerivativeSpikedGradient(dist);
        float3 dir = dist > 0 ? particleOffset / dist : float3(0, 1, 0);
        pressureForce += dir * gradientInfl * GetSharedPressure(_particles[id.x].density[0], _particles[i].density[0]) / _particles[i].density[0];
        gradientInfl = NearDerivativeDensityKernel_GreaterDerivativeSpikedGradient(dist);
        pressureForce += dir * gradientInfl * GetNearSharedPressure(_particles[id.x].density[1], _particles[i].density[1]) / _particles[i].density[1];

    }
    float3 acceleration = pressureForce / density;
    _particles[id.x].pressure = acceleration * timestep;
}


[numthreads(100, 1, 1)]
void CalculateViscosity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength)
        return;
    
    float3 viscosityForce = 0;
    float3 particlePos = _particles[id.x].positionPrediction;
    float3 currentVel = _particles[id.x].velocity;
    for (int i = 0; i < particleLength; i++)
    {
        if (id.x == i) continue; // SIM DOES NOT WORK WITHOUT THIS AS IT WILL BREAK DUE TO INCLUDING ITSELF IN THE LOOP, RETURNING 0;
        float3 particleOffset = (_particles[i].positionPrediction - particlePos);
        float partDis = dot(particleOffset, particleOffset);
        float dist = sqrt(partDis);
        float gradientInfl = ViscosityKernal_RoundedGradient(dist);
        viscosityForce += (_particles[i].velocity - currentVel) * gradientInfl;
    }
    
    _particles[id.x].velocity += (viscosityForce * viscosityMulti) * timestep;

}

[numthreads(100, 1, 1)]
void ApplyForces(uint id : SV_DispatchThreadID)
{
    _particles[id.x].external = float3(0, gravity / particleMass, 0) * timestep;
    
    _particles[id.x].velocity += _particles[id.x].external;
    
    _particles[id.x].velocity += _particles[id.x].pressure;

    _particles[id.x].position += (_particles[id.x].velocity) * timestep;
    

}


