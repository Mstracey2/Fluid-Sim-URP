#pragma kernel CalculateExternalForces
#pragma kernel CalculateDensity
#pragma kernel CalculatePressure
#pragma kernel CalculateViscosity
#pragma kernel ApplyForces
#pragma kernel GetSpacialHash

#include "./SpatialHashing.hlsl"
#include "./SPHGradients.hlsl"
#include "./SPHComputeUtility.hlsl"

struct Particle {
	float3 pressure;
	float2 density;
    float3 viscosity;
    float3 external;
	float3 velocity;
	float3 position;
    float3 positionPrediction;
    uint3 hashData;
    
    //preset values unique to particle
    float staticDensityTarget;
    float staticPressureMulti;
    float staticNearPressureMulti;
    float staticViscosityMulti;
    float3 staticColour;
};

RWStructuredBuffer<Particle> _particles;
RWStructuredBuffer<uint3> hashData;
RWStructuredBuffer<uint> hashOffsetData;

//constant
float pi;
float radius;
int particleLength;

//world
float gravity;
float boundDamping;
float timestep;

//fluid (single fluid only)
float densityTarget;
float pressureMulti;
float nearPressureMulti;
float viscosityMulti;
float predictionIteration;

//box transform
float4x4 worldMatrix;
float4x4 localMatrix;

//Mouse
float3 mousePos;
float mouseRadius;
float pushPullForce;
bool pull;
bool push;

//multi or single fluids?
bool staticFluidMultipliers;

static const int xThreads = 100;

void DetectBounds(uint idex)
{
    
    // Transform position/velocity to the local space
    float3 posLocal = mul(localMatrix, float4(_particles[idex].position, 1)).xyz;
    float3 velocityLocal = mul(localMatrix, float4(_particles[idex].velocity, 0)).xyz;
    
    //get the distance of boxes axises
    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);
    
    // Resolve collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * boundDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * boundDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * boundDamping;
    }
    
    
    _particles[idex].position = mul(worldMatrix, float4(posLocal, 1)).xyz;
    _particles[idex].velocity = mul(worldMatrix, float4(velocityLocal, 0)).xyz;
    
    
}

// Calculates the density of the particle, does so by getting the neighboring particles, and the density is affected via the gradient influence.
[numthreads(xThreads, 1, 1)]
void CalculateDensity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    
    float dens = 0;
    float nearDens = 0;
    float radiusSqr = radius * radius;
    
    //Spatial hashing neighbor search
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    //neighboring cells and particle's current cell
    for (int i = 0; i < 27; i++)        
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);  //hash
        uint key = HashKey(neighborCellHash, particleLength);       //key
        uint currentOffsetKey = hashOffsetData[key];                //position in the offset buffer where the particles with the same key starts
        
        while (currentOffsetKey < particleLength)
        {
            uint3 cellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            //if we are no longer looking at the right key, all neighbors in cell have been taken into account so break this loop
            if (cellData[2] != key)
            {
                break;
            }
            
            //if neighbor does not have equal hash (basically within the particle's radius), continue searching neighbors
            if (cellData[1] != neighborCellHash)
            {
                continue;
            }
            
            // neighbor particle is found!
            uint neighbor = cellData[0];
            
            // distance from neighbor
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);

            //NOTE: there is a chance that a hash can end up being the same in a different cell, due to limitations of the prime number, so we also check if its within the radius of the particle
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            
            //spiky density gradient
            float gradientInfl = DensityKernal_SpikedGradient(dist[1], radius, pi);
            dens += gradientInfl;
            
            //spiky near density gradient
            gradientInfl = NearDensityKernal_GreaterSpikedGradient(dist[1], radius, pi);
            nearDens += gradientInfl ;
        }
    }
    
    _particles[id.x].density = float2(dens, nearDens) ;
	
}

// calculates particle pressure, REQUIRES THE CALCULATION OF DENSITY.
[numthreads(xThreads, 1, 1)]
void CalculatePressure(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    float3 particlePos = _particles[id.x].positionPrediction;
    
    float3 pressureForce = 0;
    float radiusSqr = radius * radius;
    
    
    //multi fluid = static values, single fluid = dynamic values dependant on UI sliders.
    float pressureMultiplier = staticFluidMultipliers == true ? _particles[id.x].staticPressureMulti : pressureMulti;
    float densTarget = staticFluidMultipliers == true ? _particles[id.x].staticDensityTarget : densityTarget;
    float nearPressureMultiplier = staticFluidMultipliers == true ? _particles[id.x].staticNearPressureMulti : nearPressureMulti;
    
    //Spatial hashing neighbor search
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    //neighboring cells and particle's current cell
    for (int i = 0; i < 27; i++)
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);  //hash
        uint key = HashKey(neighborCellHash, particleLength);       //key
        uint currentOffsetKey = hashOffsetData[key];                //position in the offset buffer where the particles with the same key starts
        
        
        while (currentOffsetKey < particleLength)
        {
            uint3 offsetCellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            //if we are no longer looking at the right key, all neighbors in cell have been taken into account so break this loop
            if (offsetCellData[2] != key)
            {
                break;
            }
            //if neighbor does not have equal hash (basically within the particle's radius), continue searching neighbors
            if (offsetCellData[1] != neighborCellHash)
            {
                continue;
            }
            
            // neighbor particle is found!
            uint neighbor = offsetCellData[0];
            // distance from neighbor
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);
            
            //CHECK THAT THE NEIGHBOR ISN'T ITSELF (WILL RETURN NAN)
            if (neighbor == id.x)
            {
                continue;
            }
            //NOTE: there is a chance that a hash can end up being the same in a different cell, due to limitations of the prime number, so we also check if its within the radius of the particle
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            
            //Safety buffer to avoid NaN's, can happen if particles end up in the same position. The direction will just be 'up' if this is the case
            float3 dir = dist[1] > 0 ? (_particles[neighbor].positionPrediction - particlePos) / dist[1] : float3(0, 1, 0);
            
            float gradientInfl = DerivativeDensityKernal_DerivativeSpikedGradient(dist[1], radius, pi);
            
            //APPLY GRADEINT'S INFLUENCE AND NEWTONS THIRD LAW TO THE PRESSURE FORCE (normal)
            pressureForce += dir * gradientInfl * GetSharedPressure(_particles[id.x].density[0], _particles[neighbor].density[0],id.x, densityTarget, pressureMultiplier) / _particles[neighbor].density[0];
            
            gradientInfl = NearDerivativeDensityKernel_GreaterDerivativeSpikedGradient(dist[1], radius, pi);
            
            //APPLY GRADEINT'S INFLUENCE AND NEWTONS THIRD LAW TO THE PRESSURE FORCE (near)
            pressureForce += dir * gradientInfl * GetNearSharedPressure(_particles[id.x].density[1], _particles[neighbor].density[1],id.x, nearPressureMultiplier) / _particles[neighbor].density[1];
        }
    }
    
    float3 acceleration = pressureForce / _particles[id.x].density[0];
    _particles[id.x].pressure = acceleration * timestep;

}

[numthreads(xThreads, 1, 1)]
void CalculateViscosity(uint id : SV_DispatchThreadID)
{
    if (id.x >= particleLength) return;
    
    float3 viscosityForce = 0;
    float3 particlePos = _particles[id.x].positionPrediction;
    float3 currentVel = _particles[id.x].velocity;
    float radiusSqr = radius * radius;
    
    //Spatial hashing neighbor search
    int3 particleCell = intCoord(_particles[id.x].positionPrediction, radius);
    //neighboring cells and particle's current cell 
    for (int i = 0; i < 27; i++)
    {
        uint neighborCellHash = Hash(particleCell + offsets3D[i]);  //hash
        uint key = HashKey(neighborCellHash, particleLength);       //key
        uint currentOffsetKey = hashOffsetData[key];                //position in the offset buffer where the particles with the same key starts
        
        while (currentOffsetKey < particleLength)
        {
            uint3 cellData = hashData[currentOffsetKey];
            currentOffsetKey++;
            
            //if we are no longer looking at the right key, all neighbors in cell have been taken into account so break this loop
            if (cellData[2] != key)
            {
                break;
            }
            //if neighbor does not have equal hash (basically within the particle's radius), continue searching neighbors
            if (cellData[1] != neighborCellHash)
            {
                continue;
            }
            
            // neighbor particle is found!
            uint neighbor = cellData[0];
            // distance from neighbor
            float2 dist = DistanceIn3DSpace(particlePos, _particles[neighbor].positionPrediction);
            
            //CHECK THAT THE NEIGHBOR ISN'T ITSELF (WILL RETURN NAN)
            if (neighbor == id.x)
            {
                continue;
            }
            //NOTE: there is a chance that a hash can end up being the same in a different cell, due to limitations of the prime number, so we also check if its within the radius of the particle
            if (dist[0] > radiusSqr)
            {
                continue;
            }
            
            //Rounded Gradient
            float gradientInfl = ViscosityKernal_RoundedGradient(dist[1], radius, pi);
            viscosityForce += (_particles[neighbor].velocity - currentVel) * gradientInfl;
        }
    }
    
    float multiplier = staticFluidMultipliers == true ? _particles[id.x].staticViscosityMulti : viscosityMulti;
    
    _particles[id.x].viscosity = (viscosityForce * multiplier) * timestep;

}

[numthreads(xThreads, 1, 1)]
void CalculateExternalForces(uint3 id : SV_DISPATCHTHREADID)
{
    //apply gravity
    _particles[id.x].external = float3(0, gravity, 0) * timestep;
    
    float2 dist = DistanceIn3DSpace(_particles[id.x].positionPrediction, mousePos);
    float3 dir = dist[1] > 0 ? (_particles[id.x].positionPrediction - mousePos) / dist[1] : float3(0, 1, 0);
    
    if (dist[1] < mouseRadius)
    {
        if (pull)
        {
            _particles[id.x].external -= (dir * pushPullForce) * timestep;
        }
        if (push)
        {
            _particles[id.x].external += (dir * pushPullForce) * timestep;
        }
    }
    
    _particles[id.x].positionPrediction = _particles[id.x].position + _particles[id.x].velocity * 1 / predictionIteration;
    
}

[numthreads(xThreads, 1, 1)]
void GetSpacialHash(uint3 id : SV_DISPATCHTHREADID)
{
    if (id.x >= particleLength) return;
    uint index = id.x;
    
    hashOffsetData[index] = particleLength;
    
    int3 convertedCellSpace = intCoord(_particles[index].positionPrediction, radius);
    uint hash = Hash(convertedCellSpace);
    uint Key = HashKey(hash, particleLength);
    
    //this just holds the hash data in the particle.
    _particles[index].hashData = uint3(index, hash, Key);
    
    //applies data to the hash data buffer
    hashData[index] = _particles[index].hashData;

}

[numthreads(xThreads, 1, 1)]
void ApplyForces(uint id : SV_DispatchThreadID)
{
    //applies all charactaristics
    
    _particles[id.x].velocity += _particles[id.x].external ;
    
    _particles[id.x].velocity += _particles[id.x].pressure ;

    _particles[id.x].velocity += _particles[id.x].viscosity;
    
    _particles[id.x].position += (_particles[id.x].velocity) * timestep;
    
    DetectBounds(id.x);
     
}

